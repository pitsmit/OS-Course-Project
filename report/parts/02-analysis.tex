\chapter{Аналитический раздел}

\section{Постановка задачи}

В соответствии с заданием на курсовую работу необходимо разработать модуль ядра 
для подмены пользовательских данных, передаваемых на USB-накопители. 
Для решения поставленной задачи необходимо:

\begin{enumerate}
    \item провести анализ функций и структур ядра для работы с USB-устройствами;
    \item провести анализ методов перехвата управления у функций ядра;
    \item провести анализ методов подмены и повреждения информации;
    \item провести анализ работы файловой системы FAT32;
    \item провести анализ способа синхронизации кэша процессора с физической памятью;
    \item реализовать и протестировать модуль.
\end{enumerate}

%\section{Архитектура подсистемы USB в Linux}
%
%Основные компоненты, реализующие работу с USB-устройствами~\cite{MasterUSB}:
%
%\begin{enumerate}
%    \item драйвер устройства;
%    \item ядро USB (USB Core) -- общий код, управляющий всей подсистемой;
%    \item драйвер хост-контроллера (HCD) -- реализует программно-аппаратное взаимодействие.
%\end{enumerate}
%
%Схема взаимодействия драйверов USB:
%
%\begin{enumerate}
%\item драйвер устройства создает или получает запрос на передачу информации;
%\item драйвер инициализирует запрос всей необходимой информацией:
%    \begin{itemize}[label=---]
%        \item тип запроса (чтение, запись, управление);
%        \item адрес устройства и номер конечной точки (endpoint);
%        \item указатель на буфер данных;
%        \item размер буфера данных;
%        \item функция обратного вызова (callback) -- которая будет вызвана, когда операция завершится.
%    \end{itemize}
%\item драйвер отправляет запрос в ядро USB;
%\item ядро и HCD выполняют необходимую низкоуровневую работу, чтобы выполнить этот запрос на физической шине USB;
%\item когда операция завершена (данные получены, отправлены или произошла ошибка), HCD вызывает функцию обратного 
%вызова для этого запроса, чтобы уведомить драйвер устройства о результате.
%\end{enumerate}

\section{Анализ структур ядра USB-подсистемы}

Для управления внешним накопителем, таким как USB-устройство в операционной 
системе представлено несколько структур.

\subsection{Анализ структуры usb\_device}

Структура \texttt{usb\_device} отвечает за представление USB-устройства в ядре.
В листинге~\ref{lst:usb_device.c} представлены основные поля этой структуры~\cite{LinuxCode}.

\includelisting
    {usb_device.c}
    {Определение структуры usb\_device (часть 1)}

\includelisting
    {usb_device_2.c}
    {Определение структуры usb\_device (часть 2)}

\subsubsection{Анализ полей структуры usb\_device}

\begin{itemize}[label=---]
\item \texttt{devnum} --- номер устройства в системе. Уникальный идентификатор, присваиваемый 
устройству при его подключении;
\item \texttt{devpath[16]} --- путь к устройству в дереве USB. Строка, представляющая 
путь от корневого хаба до устройства;
\item \texttt{state} --- текущее состояние устройства;
\item \texttt{descriptor} --- содержит стандартный дескриптор 
устройства (идентификатор производителя, идентификатор продукта, версия устройства и т.д.);
\item \texttt{can\_submit} --- флаг, указывающий, может ли устройство отправлять URBs;
\item \texttt{product} --- название или модель самого устройства;
\item \texttt{manufacturer} --- название компании-производителя устройства;
\item \texttt{serial} --- уникальный строковый идентификатор конкретного экземпляра устройства.
\end{itemize}

\subsection{Анализ структуры urb}

URB(User Request Block) инкапсулирует запрос на передачу данных, передаваемый 
драйвером USB-устройства низкоуровневому драйверу хост-контроллера. 
В листинге~\ref{lst:urb.c} представлены основные поля этой структуры~\cite{LinuxCode}.
\newpage
\includelisting
    {urb.c}
    {Определение структуры URB}

\subsubsection{Анализ полей структуры URB}

\begin{itemize}[label=---]
    \item \texttt{dev} --- представление устройства USB;
    \item \texttt{status} --- статус выполнения;
    \item \texttt{transfer\_flags} --- флаги передачи. Флаг URB\_NO\_TRANSFER\_DMA\_MAP
    сообщает драйверу хост-контроллера, что драйвер устройства поддерживает DMA(Direct Memory Access);
    \item \texttt{transfer\_buffer} --- указатель на область данных для передачи;
    \item \texttt{transfer\_dma} --- физический адрес передаваемых данных. Если установлен 
    флаг URB\_NO\_TRANSFER\_DMA\_MAP драйвер устройства сообщает, что он предоставил этот адрес DMA,
    который драйвер хост-контроллера должен использовать предпочтительнее, чем transfer\_buffer;
    \item \texttt{sg} --- указатель на начало списка разрозненных буферов для передачи;
    \item \texttt{num\_sgs} --- длина списка разрозненных буферов;
    \item \texttt{transfer\_buffer\_length} --- размер передаваемого буфера;
    \item \texttt{actual\_length} --- фактически переданное количество байт;
    \item \texttt{complete} --- функция обратного вызова. Используется для освобождения
    или повторной отправки URB.
\end{itemize}

\subsubsection{Типы передач, поддерживаемые URB}

URB поддерживает все четыре типа передач, определенные в спецификации USB~\cite{ShinaUSB}:

\begin{enumerate}
\item управляющие посылки (Control Transfers), используемые для конфигурирования во время подключения 
и в процессе работы для управления устройствами.
\item сплошные передачи (Bulk Data Transfers) сравнительно больших пакетов без жестких требований 
ко времени доставки. Приоритет этих передач самый низкий, они могут приостанавливаться при большой загрузке шины.
\item прерывания (Interrupt) --- короткие передачи, имеют спонтанный характер и должны обслуживаться не 
медленнее, чем того требует устройство. 
\item изохронные передачи (Isochronous Transfers) --- непрерывные передачи в реальном времени, 
занимающие предварительно согласованную часть пропускной способности шины и имеющие заданную 
задержку доставки.
\end{enumerate}

Каждая операция ввода-вывода через USB шину оформляется в виде отдельного 
URB, что обеспечивает единый интерфейс для работы с различными типами USB-передач.

\section{Анализ функций ядра для работы с USB}

Для работы с устройствами USB в ядре существует множество функций, описанных
в файлах \texttt{/drivers/usb/core/urb.c}, \texttt{/drivers/usb/core/usb.c}, 
\texttt{/drivers/usb/core/hcd.c}.

\subsection{Анализ функции usb\_submit\_urb}

Функция отправляет запрос на передачу, передавая URB, описывающее этот запрос, 
в подсистему USB. Завершение запроса идентифицируется позднее, асинхронно,
при вызове обработчики завершения. В листинге~\ref{lst:usb_submit_urb.c} представлены 
основные этапы выполнения функции~\cite{LinuxCode}.

\includelisting
    {usb_submit_urb.c}
    {Основные этапы выполнения функции usb\_submit\_urb}

URBs могут отправляться конечным точкам до завершения предыдущих, чтобы минимизировать 
задержки. Таким образом очередь на конечной точке никогда не будет пустой. Такая 
организация позволяет максимально эффективно использовать полосу пропускания, позволяя 
USB контроллерам начинать работу с более поздними запросами до того, как программное 
обеспечение драйвера завершит обработку более ранних запросов.

В случае успеха функция возвращает 0, иначе -- отрицательный номер ошибки.

\subsection{Анализ функции usb\_hcd\_link\_urb\_to\_ep}

Функция добавляет URB в очередь конечной точки. Принимает структуру хост-контроллера,
на который был отправлен URB и сам URB. В листинге~\ref{lst:usb_hcd_link_urb_to_ep.c} 
представлены основные этапы выполнения функции~\cite{LinuxCode}.

\includelisting
    {usb_hcd_link_urb_to_ep.c}
    {Основные этапы выполнения функции usb\_hcd\_link\_urb\_to\_ep}

Драйверы хост-контроллера должны вызывать эту процедуру в своем методе \texttt{enqueue()}. 
Возвращает значение 0, если ошибки нет, в противном случае возвращается отрицательный код 
ошибки (в этом случае метод \texttt{enqueue()} должен завершиться ошибкой).

\section{Анализ методов перехвата управления у функций ядра}

В ядре Linux существует несколько механизмов перехвата управления 
у функций ядра.

\subsection{kprobes}

Kprobes --- это средс­тво динами­чес­кой отладки ядра, поз­воля­ющее ста­вить точки останова(breakpoints) на 
дос­тупные для записи учас­тки памяти и самос­тоятель­но обра­баты­вать их. Описывается структурой
\texttt{kprobe}, имеющей следующие поля:

\includelisting
    {kprobe.c}
    {Определение структуры kprobe}

\begin{itemize}[label=---]
    \item \texttt{symbol\_name} --- имя функции, на которую ставится breakpoint;
    \item \texttt{pre\_handler} --- указатель на функцию обработки точки останова до выполнения 
    основной функции;
    \item \texttt{post\_handler} --- указатель на функцию обработки точки останова после 
    выполнения основной функции;
    \item \texttt{addr} --- адрес функции, на которую ставится breakpoint. Должно быть указано 
    либо имя функции, либо её адрес, если заполнены оба поля, то регистрация kprobe вернёт 
    ошибку -EINVAL~\cite{Kprobes}.
\end{itemize}
\newpage
Добавление и удаление точек останова выполняют следующие функции:

\includelisting
    {kprobe_reg_unreg.c}
    {Функции добавления и удаления kprobes}

\subsection{Livepatch}

Livepatch (Kernel Live Patching) --- механизм для динамического обновления работающего ядра без 
перезагрузки системы. Он позволяет заменять функции ядра на новые версии "на лету". Хотя изначально 
предназначен для исправления уязвимостей, его можно адаптировать для перехвата вызовов функций 
путём замены оригинальных функций на модифицированные.

Структура \texttt{klp\_func} описывает подменяемую функцию:

\includelisting
    {klp-func.c}
    {Определение структуры klp\_func}

\begin{itemize}[label=---]
\item \texttt{old\_name} --- имя оригинальной функции;
\item \texttt{new\_func} --- указатель на исправленную функцию;
\item \texttt{old\_func} --- указатель на заменяемую функцию;
\item \texttt{stack\_node} --- узел списка для отслеживания вызовов функции;
\item \texttt{patched} --- флаг, указывающий, применён ли патч к данной функции.
\end{itemize}

Структура \texttt{klp\_object} описывает модуль, содержащий функции для замены:

\includelisting
    {klp-object.c}
    {Определение структуры klp\_object}

\begin{itemize}[label=---]
\item \texttt{name} --- имя модуля;
\item \texttt{funcs} --- список функций для патчинга;
\item \texttt{mod} --- указатель на структуру модуля;
\item \texttt{patched} --- флаг, указывающий, применён ли патч ко всем функциям объекта.
\end{itemize}

Структура \texttt{klp\_patch} описывает единый патч, который может включать несколько объектов:

\includelisting
    {klp-patch.c}
    {Определение структуры klp\_patch}

\begin{itemize}[label=---]
\item \texttt{mod} --- указатель на модуль, реализующий патч;
\item \texttt{objs} --- объекты, входящие в патч;
\item \texttt{replace} --- флаг, указывающий, должен ли патч заменять предыдущие патчи;
\item \texttt{list} --- узел для включения в глобальный список патчей;
\item \texttt{enabled} --- флаг активности патча.
\end{itemize}

Для включения патча необходимо вызвать следующую функцию:

\includelisting
    {klp-enable-patch.c}
    {Основные этапы выполнения функции klp\_enable\_patch}

\subsection{Выбор метода перехвата управления у функций ядра}

Для выбора оптимального метода перехвата управления у функций были 
определены следующие критерии:

\begin{enumerate}
    \item необходимость полной замены функции;
    \item количество структур, которые надо инициализировать;
    \item минимальная версия ядра;
    \item есть ли прямой доступ к аргументам функции (без использования регистров).
\end{enumerate}

В таблице~\ref{tab:compareperexvat} представлено сравнение рассмотренных методов.

\begin{table}[H]
\caption{Сравнение методов перехвата управления}
\begin{tabular}{|l|c|c|c|c|c|}
\hline
Метод & 1 & 2 & 3 & 4 \\
\hline
kprobes & нет & 1 & 2.6.9 & нет \\
\hline
Livepatch & да & 3 & 4.0 & да \\
\hline
\end{tabular}
\label{tab:compareperexvat}
\end{table}

На основании анализа таблицы для реализации в модуле ядра выбран механизм kprobes, 
так как он:
\begin{itemize}[label=---]
    \item проще и быстрее в реализации;
    \item поддерживается большим количеством версий ядра;
    \item не требует полной переписи оригинальной функции.
\end{itemize}

\section{Анализ методов подмены информации}

В данном разделе рассматриваются три подхода: побайтовая замена на константу, 
заполнение случайными данными и метод Гутмана.

\subsection{Побайтовая замена на константу}

Наиболее простым методом уничтожения информации является 
замена исходных данных фиксированным значением (чаще всего нулями) 
с помощью функции \texttt{memset()}. Данный подход реализуется 
минимальными вычислительными затратами, однако обладает 
существенным недостатком --- при последующем чтении данных файлов с флешки
будет очевидно, что содержимое файла было изменено сторонним модулем.

\subsection{Заполнение случайными данными}

Более надёжным методом является перезапись данных 
криптографически стойкими случайными значениями с помощью 
функции ядра Linux \texttt{get\_random\_bytes()}. Данная функция 
использует криптографически стойкий генератор псевдослучайных 
чисел (CSPRNG), что обеспечивает непредсказуемость записываемых 
данных~\cite{CSPRNG}.

\subsection{Метод Гутмана}

Метод Гутмана предполагает 35 циклов перезаписи специально 
подобранными паттернами, разработанными для преодоления 
особенностей работы накопителей на магнитных дисках. 
Для современных твердотельных накопителей (SSD) и флеш-памяти 
этот метод является избыточным, так как контроллеры таких 
устройств используют выравнивание износа и другие механизмы, 
которые делают многократную перезапись неэффективной~\cite{GutMan}.

\subsection{Выбор метода подмены информации}

Для выбора оптимального метода подмены информации были 
определены следующие критерии:

\begin{enumerate}
    \item количество проходов записи --- число циклов перезаписи данных;
    \item объем дополнительной памяти --- память для хранения паттернов или буферов;
    \item наличие готовой реализации в ядре Linux;
    \item криптографическая стойкость --- использование криптографически стойкого генератора 
    случайных чисел;
    \item применимость для современных USB-накопителей.
\end{enumerate}

В таблице~\ref{tab:compareshifr} представлено сравнение рассмотренных методов.

\begin{table}[H]
\caption{Сравнение методов подмены информации}
\begin{tabular}{|l|c|c|c|c|c|}
\hline
Метод & 1 & 2 & 3 & 4 & 5 \\
\hline
Замена нулями & 1 & 0 байт & да & нет & нет \\
\hline
Метод Гутмана & 35 & 35 байт & нет & нет & нет \\
\hline
Случайные данные & 1 & 0 байт & да & да & да \\
\hline
\end{tabular}
\label{tab:compareshifr}
\end{table}

На основании анализа таблицы для реализации в модуле ядра выбран метод 
заполнения случайными данными через \texttt{get\_random\_bytes()}, так как он:
\begin{itemize}[label=---]
    \item требует минимального количества проходов;
    \item не использует дополнительную память;
    \item реализован в ядре Linux;
    \item обеспечивает криптографическую стойкость через CSPRNG;
    \item эффективен для современных флеш-накопителей.
\end{itemize}

\section{Файловая система FAT32}

На рисунке~\ref{img:FAT} изображена структура раздела FAT~\cite{FAT32}:

\includeimage
    {FAT}
    {f}
    {H}
    {0.50\textwidth}
    {Структура раздела FAT32}

В файловой системе FAT дисковое пространство логического раздела делится на две 
области -- системную и область данных. Системная область создается и инициализируется при 
форматировании, а впоследствии обновляется при манипулировании файловой структурой.

%Область данных логического диска содержит файлы и каталоги, подчиненные корневому, и 
%разделена на участки одинакового размера -- кластеры. Кластер может состоять из одного 
%или нескольких последовательно расположенных на диске секторов. Число секторов в кластере 
%должно быть кратно степени двойки и может принимать значения от 1 до 64. 
%
%Каждому кластеру соответствует элемент таблицы FAT, содержащий информацию о том, свободен 
%данный кластер или занят данными файла. Если кластер занят под файл, то в соответствующем
%элементе таблицы размещения файлов указывается адрес кластера, содержащего следующую часть 
%файла. Номер начального кластера, занятого файлом, хранится в элементе каталога, 
%содержащего запись об этом файле. Последний элемент списка кластеров содержит признак
%конца файла. Первые два элемента FAT являются резервными.

В FAT32 корневой каталог может быть расположен в любом месте области данных раздела и 
иметь произвольный размер. Структура элемента каталога файлов показана на 
рисунке~\ref{img:CatalogFAT}. Элемент начинается с 11-байтного поля, содержащего «короткое имя» 
файла, по которому операционная система обычно осуществляет поиск файла в каталоге. 
«Короткое имя» состоит из двух полей: 8-байтного поля, содержащего собственно имя файла 
и 3-байтного поля, содержащего расширение. Разделительная точка между именем и расширением 
файла не хранится в структуре данных.

\includeimage
    {CatalogFAT}
    {f}
    {H}
    {0.90\textwidth}
    {Структура элемента каталога}

В ядре Linux элемент каталога представлен структурой \texttt{msdos\_dir\_entry}:

\includelisting
    {msdos_dir_entry.c}
    {Определение структуры msdos\_dir\_entry}

4-ый бит в поле attr, равный единице, определяет файл как каталог.
Если первый байт поля name равен 0xE5, то элемент каталога свободен и его можно 
использовать при создании нового файла.

В первом секторе резервной области присутствует структура FSINFO. Эта структура 
содержит информацию о количестве свободных кластеров на диске и о номере первого 
свободного кластера в таблице FAT. В Linux описывается структурой 
\texttt{fat\_boot\_fsinfo}:

\includelisting
    {fat_boot_fsinfo.c}
    {Определение структуры fat\_boot\_fsinfo}

Поле \texttt{signature1} --- признак того, что данные сектор содержит структуру FSINFO. Значение
поля определено макросом \texttt{\#define FAT\_FSINFO\_SIG1	0x41615252}.

Поля \texttt{attr}, \texttt{name} в структуре \texttt{msdos\_dir\_entry} и 
\texttt{signature1} в структуре \texttt{fat\_boot\_fsinfo} позволяют отличать 
служебные FAT32 данные в передаваемых URB от непосредственно содержимого файлов.

\section{Синхронизация кэша при работе с DMA}

При перехвате URB-запросов и модификации передаваемых данных необходимо обеспечить 
согласованность между кэшем центрального процессора и физической памятью. 
Драйвер хост-контроллера USB использует прямой доступ к памяти (DMA) для чтения 
данных непосредственно из физических адресов, минуя кэш процессора.

Чтобы гарантировать, что контроллер получает актуальные модифицированные данные, требуется 
явная синхронизация кэша. Для этого используется функция \texttt{dma\_sync\_single\_for\_device}, 
которая обеспечивает запись изменений из кэша процессора в физическую память перед началом 
операции DMA от устройства. Код функции представлен в листинге~\ref{lst:dma-sync.c}

\includelisting
    {dma-sync.c}
    {Код функции dma\_sync\_single\_for\_device}

\section{Выводы}

В результате проведённого анализа были выбраны механизм перехвата управления у функций
ядра, метод подмены информации, рассмотрены структуры и функции для работы с USB подсистемой,
выделены необходимые поля в структурах FAT32, и рассмотрена синхронизация кэша процессора.

В качестве механизма перехвата управления был выбран kprobes, так как он проще и быстрее в реализации,
поддерживается большим количеством версий ядра, не требует полной переписи оригинальной функции.

Для подмены информации был выбран метод заполнения случайными данными через 
\texttt{get\_random\_bytes()}, так как он не использует дополнительную память, реализован в ядре Linux и 
обеспечивает криптографическую стойкость через CSPRNG.

Для идентификации служебных FAT32 данных в передаваемых URB были выделены поля \texttt{attr}, 
\texttt{name} в структуре \texttt{msdos\_dir\_entry} и \texttt{signature1} в структуре 
\texttt{fat\_boot\_fsinfo}.

Для синхронизации кэша процессора и физической памяти была рассмотрена функция 
\texttt{dma\_sync\_single\_for\_device}.