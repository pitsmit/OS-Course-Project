\chapter{Аналитический раздел}

\section{Постановка задачи}

В соответствии с заданием на курсовую работу необходимо разработать модуль ядра 
для подмены пользовательских данных, передаваемых на USB-накопители. 
Для решения поставленной задачи необходимо:

\begin{enumerate}
    \item провести анализ функций и структур ядра для работы с USB-устройствами;
    \item провести анализ методов перехвата управления у функций ядра;
    \item провести анализ методов подмены и повреждения информации;
    \item провести анализ работы файловой системы FAT32;
    \item реализовать и протестировать модуль.
\end{enumerate}

%\section{Архитектура подсистемы USB в Linux}
%
%Основные компоненты, реализующие работу с USB-устройствами~\cite{MasterUSB}:
%
%\begin{enumerate}
%    \item драйвер устройства;
%    \item ядро USB (USB Core) -- общий код, управляющий всей подсистемой;
%    \item драйвер хост-контроллера (HCD) -- реализует программно-аппаратное взаимодействие.
%\end{enumerate}
%
%Схема взаимодействия драйверов USB:
%
%\begin{enumerate}
%\item драйвер устройства создает или получает запрос на передачу информации;
%\item драйвер инициализирует запрос всей необходимой информацией:
%    \begin{itemize}[label=---]
%        \item тип запроса (чтение, запись, управление);
%        \item адрес устройства и номер конечной точки (endpoint);
%        \item указатель на буфер данных;
%        \item размер буфера данных;
%        \item функция обратного вызова (callback) -- которая будет вызвана, когда операция завершится.
%    \end{itemize}
%\item драйвер отправляет запрос в ядро USB;
%\item ядро и HCD выполняют необходимую низкоуровневую работу, чтобы выполнить этот запрос на физической шине USB;
%\item когда операция завершена (данные получены, отправлены или произошла ошибка), HCD вызывает функцию обратного 
%вызова для этого запроса, чтобы уведомить драйвер устройства о результате.
%\end{enumerate}

\section{Анализ структур ядра USB-подсистемы}

Для управления внешним накопителем, таким как USB-устройство в операционной 
системе представлено несколько структур.

\subsection{Анализ структуры usb\_device}

Структура \texttt{usb\_device} отвечает за представление USB-устройства в ядре.
В листинге~\ref{lst:usb_device.c} представлены основные поля этой структуры~\cite{LinuxCode}.

\includelisting
    {usb_device.c}
    {Определение структуры usb\_device}

\subsubsection{Анализ полей структуры usb\_device}

\begin{itemize}[label=---]
\item \texttt{devnum} --- номер устройства в системе. Уникальный идентификатор, присваиваемый 
устройству при его подключении;
\item \texttt{devpath[16]} --- путь к устройству в дереве USB. Строка, представляющая 
путь от корневого хаба до устройства;
\item \texttt{state} --- текущее состояние устройства;
\item \texttt{descriptor} --- содержит стандартный дескриптор 
устройства (идентификатор производителя, идентификатор продукта, версия устройства и т.д.);
\item \texttt{can\_submit} --- флаг, указывающий, может ли устройство отправлять URBs;
\item \texttt{product} --- название или модель самого устройства;
\item \texttt{manufacturer} --- название компании-производителя устройства;
\item \texttt{serial} --- уникальный строковый идентификатор конкретного экземпляра устройства.
\end{itemize}

\subsection{Анализ структуры urb}

URB(User Request Block) инкапсулирует запрос на передачу данных, передаваемый 
драйвером USB-устройства низкоуровневому драйверу хост-контроллера. 
В листинге~\ref{lst:urb.c} представлены основные поля этой структуры~\cite{LinuxCode}.

\includelisting
    {urb.c}
    {Определение структуры URB}

\subsubsection{Анализ полей структуры URB}

\begin{itemize}[label=---]
    \item \texttt{dev} --- представление устройства USB;
    \item \texttt{status} --- статус выполнения;
    \item \texttt{transfer\_flags} --- флаги передачи. Флаг URB\_NO\_TRANSFER\_DMA\_MAP
    сообщает драйверу хост-контроллера, что драйвер устройства поддерживает DMA(Direct Memory Access);
    \item \texttt{transfer\_buffer} --- указатель на область данных для передачи;
    \item \texttt{transfer\_dma} --- физический адрес передаваемых данных. Если установлен 
    флаг URB\_NO\_TRANSFER\_DMA\_MAP драйвер устройства сообщает, что он предоставил этот адрес DMA,
    который драйвер хост-контроллера должен использовать предпочтительнее, чем transfer\_buffer;
    \item \texttt{sg} --- указатель на начало списка разрозненных буферов для передачи;
    \item \texttt{num\_sgs} --- длина списка разрозненных буферов;
    \item \texttt{transfer\_buffer\_length} --- размер передаваемого буфера;
    \item \texttt{actual\_length} --- фактически переданное количество байт;
    \item \texttt{complete} --- функция обратного вызова. Используется для освобождения
    или повторной отправки URB.
\end{itemize}

\subsubsection{Типы передач, поддерживаемые URB}

URB поддерживает все четыре типа передач, определенные в спецификации USB~\cite{ShinaUSB}:

\begin{enumerate}
\item управляющие посылки (Control Transfers), используемые для конфигурирования во время подключения 
и в процессе работы для управления устройствами.
\item сплошные передачи (Bulk Data Transfers) сравнительно больших пакетов без жестких требований 
ко времени доставки. Приоритет этих передач самый низкий, они могут приостанавливаться при большой загрузке шины.
\item прерывания (Interrupt) --- короткие передачи, имеют спонтанный характер и должны обслуживаться не 
медленнее, чем того требует устройство. 
\item изохронные передачи (Isochronous Transfers) --- непрерывные передачи в реальном времени, 
занимающие предварительно согласованную часть пропускной способности шины и имеющие заданную 
задержку доставки.
\end{enumerate}

Каждая операция ввода-вывода через USB шину оформляется в виде отдельного 
URB, что обеспечивает единый интерфейс для работы с различными типами USB-передач.

\section{Анализ функций ядра для работы с USB}

Для работы с устройствами USB в ядре существует множество функций, описанных
в файлах \texttt{/drivers/usb/core/urb.c}, \texttt{/drivers/usb/core/usb.c}, 
\texttt{/drivers/usb/core/hcd.c}.

\subsection{Анализ функции usb\_submit\_urb}

Функция отправляет запрос на передачу, передавая URB, описывающее этот запрос, 
в подсистему USB. Завершение запроса идентифицируется позднее, асинхронно,
при вызове обработчики завершения. В листинге~\ref{lst:usb_submit_urb.c} представлены 
основные этапы выполнения функции~\cite{LinuxCode}.

\includelisting
    {usb_submit_urb.c}
    {Основные этапы выполнения функции usb\_submit\_urb}

URBs могут отправляться конечным точкам до завершения предыдущих, чтобы минимизировать 
задержки. Таким образом очередь на конечной точке никогда не будет пустой. Такая 
организация позволяет максимально эффективно использовать полосу пропускания, позволяя 
USB контроллерам начинать работу с более поздними запросами до того, как программное 
обеспечение драйвера завершит обработку более ранних запросов.

В случае успеха функция возвращает 0, иначе -- отрицательный номер ошибки.

\subsection{Анализ функции usb\_hcd\_link\_urb\_to\_ep}

Функция добавляет URB в очередь конечной точки. Принимает структуру хост-контроллера,
на который был отправлен URB и сам URB. В листинге~\ref{lst:usb_hcd_link_urb_to_ep.c} 
представлены основные этапы выполнения функции~\cite{LinuxCode}.

\includelisting
    {usb_hcd_link_urb_to_ep.c}
    {Основные этапы выполнения функции usb\_hcd\_link\_urb\_to\_ep}

Драйверы хост-контроллера должны вызывать эту процедуру в своем методе \texttt{enqueue()}. 
Возвращает значение 0, если ошибки нет, в противном случае возвращается отрицательный код 
ошибки (в этом случае метод \texttt{enqueue()} должен завершиться ошибкой).

\section{Анализ методов перехвата управления у функций ядра}

В ядре Linux существует несколько механизмов отладки функций ядра.

\subsection{kprobes}

Kprobes -- это средс­тво динами­чес­кой отладки ядра, поз­воля­ющее ста­вить breakpoints на 
дос­тупные для записи учас­тки памяти и самос­тоятель­но обра­баты­вать их. Описывается структурой
\texttt{kprobes}, имеющей следующие поля:

\begin{itemize}[label=---]
    \item \texttt{const char *symbol\_name} -- имя функции, на которую ставится breakpoint;
    \item \texttt{kprobe\_pre\_handler\_t pre\_handler} -- указатель на функцию обработки точки
    останова до выполнения основной функции;
    \item \texttt{kprobe\_post\_handler\_t post\_handler} -- указатель на функцию обработки точки
    останова после выполнения основной функции;
    \item \texttt{kprobe\_opcode\_t *addr} -- адрес функции, на которую ставится breakpoint.
    Должно быть указано либо имя функции, либо её адрес, если заполнены оба поля, то 
    регистрация kprobe вернёт ошибку -EINVAL~\cite{Kprobes}.
\end{itemize}

Добавление и удаление точек останова выполняют следующие функции:

\includelisting
    {kprobe_reg_unreg.c}
    {Функции добавления и удаления kprobes}

\subsection{Livepatch}

Livepatch -- это механизм динамического обновления ядра Linux, который позволяет применять 
исправления критических уязвимостей и ошибок без перезагрузки системы. Основан на подмене 
целых функций ядра на их исправленные версии во время выполнения системы.

Структура \texttt{klp\_func} описывает подменяемую функцию:

\begin{itemize}[label=---]
\item \texttt{const char *old\_name} -- имя оригинальной функции;
\item \texttt{void *new\_func} -- указатель на исправленную функцию;
\item \texttt{struct list\_head stack\_node} -- узел списка для отслеживания вызовов функции;
\item \texttt{bool patched} -- флаг, указывающий, применён ли патч к данной функции.
\end{itemize}

Структура \texttt{klp\_object} описывает модуль, содержащий функции для замены:

\begin{itemize}[label=---]
\item \texttt{const char *name} -- имя модуля;
\item \texttt{struct module *mod} -- указатель на структуру модуля;
\item \texttt{struct klp\_func *funcs} -- список функций для патчинга;
\item \texttt{bool patched} -- флаг, указывающий, применён ли патч ко всем функциям объекта.
\end{itemize}

Структура \texttt{klp\_patch} описывает единый патч, который может включать несколько объектов:

\begin{itemize}[label=---]
\item \texttt{struct list\_head list} -- узел для включения в глобальный список патчей;
\item \texttt{struct klp\_object *objs} -- объекты, входящие в патч;
\item \texttt{struct module *mod} -- указатель на модуль, реализующий патч;
\item \texttt{bool enabled} -- флаг активности патча;
\item \texttt{bool replace} -- флаг, указывающий, должен ли патч заменять предыдущие патчи.
\end{itemize}

Для включения патча необходимо вызвать следующую функцию:

int klp\_enable\_patch(struct klp\_patch *patch)

Она инициализирует структуру \texttt{klp\_patch}, выполняет необходимый поиск символов и 
перемещение кода, регистрирует исправленные функции с помощью ftrace.

\subsection{Выбор метода динамической отладки функций ядра}

Для реализации поставленной задачи \texttt{Livepatch} избыточен, так как необходимо не исправлять 
ошибку в ядре, а добавлять новую функциональность. К тому же подменённая функция вызывалась бы
для всех USB устройств, а не для конкретной флешки, что невыгодно и может нарушить 
работу других устройств. Единственным вариантом остаётся \texttt{kprobes}.

\section{Анализ методов подмены информации}

В данном разделе рассматриваются три подхода: побайтовая замена на константу, 
заполнение случайными данными и метод Гутмана.

\subsection{Побайтовая замена на константу}

Наиболее простым методом уничтожения информации является 
замена исходных данных фиксированным значением (чаще всего нулями) 
с помощью функции \texttt{memset()}. Данный подход реализуется 
минимальными вычислительными затратами, однако обладает 
существенным недостатком --- при последующем чтении данных файлов с флешки
будет очевидно, что содержимое файла было изменено сторонним модулем.

\subsection{Заполнение случайными данными}

Более надёжным методом является перезапись данных 
криптографически стойкими случайными значениями с помощью 
функции ядра Linux \texttt{get\_random\_bytes()}. Данная функция 
использует криптографически стойкий генератор псевдослучайных 
чисел (CSPRNG), что обеспечивает непредсказуемость записываемых 
данных~\cite{CSPRNG}.

\subsection{Метод Гутмана}

Метод Гутмана предполагает 35 циклов перезаписи специально 
подобранными паттернами, разработанными для преодоления 
особенностей работы накопителей на магнитных дисках. 
Для современных твердотельных накопителей (SSD) и флеш-памяти 
этот метод является избыточным, так как контроллеры таких 
устройств используют выравнивание износа и другие механизмы, 
которые делают многократную перезапись неэффективной~\cite{GutMan}.

\subsection{Выбор метода подмены информации}

Для выбора оптимального метода подмены информации были 
определены следующие критерии:

\begin{enumerate}
    \item количество проходов записи --- число циклов перезаписи данных;
    \item объем дополнительной памяти --- память для хранения паттернов или буферов;
    \item наличие готовой реализации в ядре Linux;
    \item криптографическая стойкость --- использование криптографически стойкого генератора 
    случайных чисел;
    \item применимость для современных USB-накопителей.
\end{enumerate}

В таблице~\ref{tab:compareshifr} представлено сравнение рассмотренных методов.

\begin{table}[H]
\caption{Сравнение методов подмены информации}
\begin{tabular}{|l|c|c|c|c|c|}
\hline
Метод & 1 & 2 & 3 & 4 & 5 \\
\hline
Замена нулями & 1 & 0 байт & да & нет & нет \\
\hline
Метод Гутмана & 35 & 35 байт & нет & нет & нет \\
\hline
Случайные данные & 1 & 0 байт & да & да & да \\
\hline
\end{tabular}
\label{tab:compareshifr}
\end{table}

На основании анализа таблицы для реализации в модуле ядра выбран метод 
заполнения случайными данными через \texttt{get\_random\_bytes()}, так как он:
\begin{itemize}[label=---]
    \item требует минимального количества проходов;
    \item не использует дополнительную память;
    \item реализован в ядре Linux;
    \item обеспечивает криптографическую стойкость через CSPRNG;
    \item эффективен для современных флеш-накопителей.
\end{itemize}

\section{Файловая система FAT32}

На рисунке~\ref{img:FAT} изображена структура раздела FAT~\cite{FAT32}:

\includeimage
    {FAT}
    {f}
    {H}
    {0.50\textwidth}
    {Структура раздела FAT32}

В файловой системе FAT дисковое пространство логического раздела делится на две 
области -- системную и область данных. Системная область создается и инициализируется при 
форматировании, а впоследствии обновляется при манипулировании файловой структурой.

%Область данных логического диска содержит файлы и каталоги, подчиненные корневому, и 
%разделена на участки одинакового размера -- кластеры. Кластер может состоять из одного 
%или нескольких последовательно расположенных на диске секторов. Число секторов в кластере 
%должно быть кратно степени двойки и может принимать значения от 1 до 64. 
%
%Каждому кластеру соответствует элемент таблицы FAT, содержащий информацию о том, свободен 
%данный кластер или занят данными файла. Если кластер занят под файл, то в соответствующем
%элементе таблицы размещения файлов указывается адрес кластера, содержащего следующую часть 
%файла. Номер начального кластера, занятого файлом, хранится в элементе каталога, 
%содержащего запись об этом файле. Последний элемент списка кластеров содержит признак
%конца файла. Первые два элемента FAT являются резервными.

В FAT32 корневой каталог может быть расположен в любом месте области данных раздела и 
иметь произвольный размер. Структура элемента каталога файлов показана на 
рисунке~\ref{img:CatalogFAT}. Элемент начинается с 11-байтного поля, содержащего «короткое имя» 
файла, по которому операционная система обычно осуществляет поиск файла в каталоге. 
«Короткое имя» состоит из двух полей: 8-байтного поля, содержащего собственно имя файла 
и 3-байтного поля, содержащего расширение. Разделительная точка между именем и расширением 
файла не хранится в структуре данных.

\includeimage
    {CatalogFAT}
    {f}
    {H}
    {0.90\textwidth}
    {Структура элемента каталога}

В ядре linux элемент каталога представлен структурой \texttt{msdos\_dir\_entry}:

\includelisting
    {msdos_dir_entry.c}
    {Определение структуры msdos\_dir\_entry}

4-ый бит в поле attr, равный единице, определяет файл как каталог.
Если первый байт поля name равен 0xE5, то элемент каталога свободен и его можно 
использовать при создании нового файла.

В первом секторе резервной области присутствует структура FSINFO. Эта структура 
содержит информацию о количестве свободных кластеров на диске и о номере первого 
свободного кластера в таблице FAT. В Linux описывается структурой 
\texttt{fat\_boot\_fsinfo}:

\includelisting
    {fat_boot_fsinfo.c}
    {Определение структуры fat\_boot\_fsinfo}

Поле \texttt{signature1} --- признак того, что данные сектор содержит структуру FSINFO. Значение
поля определено макросом \texttt{\#define FAT\_FSINFO\_SIG1	0x41615252}.

Поля \texttt{attr}, \texttt{name} в структуре \texttt{msdos\_dir\_entry} и 
\texttt{signature1} в структуре \texttt{fat\_boot\_fsinfo} позволяют отличать 
служебные FAT32 данные в передаваемых URB от непосредственно содержимого файлов.


\section{Выводы}

БРЕД!!!

В результате проведённого анализа был выбран механизм динамической отладки kprobes для 
реализации модуля ядра. 
Была рассмотрена архитектура подсистемы USB в Linux, основные структуры и функции работы и 
представления USB, а также изучено строение файловой системы FAT32, на которой работает 
USB-накопитель.