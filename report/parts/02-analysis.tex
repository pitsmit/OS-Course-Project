\chapter{Аналитический раздел}

\section{Постановка задачи}

В соответствии с заданием на курсовую работу необходимо разработать модуль ядра 
для подмены пользовательских данных, передаваемых на USB-накопители. 
Подмена данных осуществляется изменением значения каждого байта данных,
с использованием XOR операции. Для достижения поставленной цели необходимо решить
следующие задачи:

\begin{enumerate}
    \item провести обзор функций и структур ядра, представляющих возможность 
    реализации разрабатываемого модуля;
    \item провести анализ методов динамической отладки функций ядра; 
    \item провести анализ работы файловой системы FAT32;
    \item реализовать и протестировать модуль.
\end{enumerate}

\section{Архитектура подсистемы USB в Linux}

Основные компоненты, реализующие работу с USB-устройствами~\cite{MasterUSB}:

\begin{enumerate}
    \item драйвер устройства;
    \item ядро USB (USB Core) -- общий код, управляющий всей подсистемой;
    \item драйвер хост-контроллера (HCD) -- реализует программно-аппаратное взаимодействие.
\end{enumerate}

Схема взаимодействия драйверов USB:

\begin{enumerate}
\item драйвер устройства создает или получает запрос на передачу информации;
\item драйвер инициализирует запрос всей необходимой информацией:
    \begin{itemize}[label=---]
        \item тип запроса (чтение, запись, управление);
        \item адрес устройства и номер конечной точки (endpoint);
        \item указатель на буфер данных;
        \item размер буфера данных;
        \item функция обратного вызова (callback) -- которая будет вызвана, когда операция завершится.
    \end{itemize}
\item драйвер отправляет запрос в ядро USB;
\item ядро и HCD выполняют необходимую низкоуровневую работу, чтобы выполнить этот запрос на физической шине USB;
\item когда операция завершена (данные получены, отправлены или произошла ошибка), HCD вызывает функцию обратного 
вызова для этого запроса, чтобы уведомить драйвер устройства о результате.
\end{enumerate}

\section{Анализ основных структур ядра для работы с USB}

Для управления внешним накопителем, таким как USB-устройство в операционной 
системе представлено несколько структур.

\subsection{struct User Request Block (URB)}

URB --- структура, инкапсулирующая запрос на передачу данных, передаваемый 
драйвером USB-устройства низкоуровневому драйверу хост-контроллера.
Каждая операция ввода-вывода через USB шину оформляется в виде отдельного 
URB, что обеспечивает единый интерфейс для работы с различными типами 
USB-передач.

\subsubsection{Типы передач, поддерживаемые URB}

URB поддерживает все четыре типа передач, определенные в спецификации USB~\cite{ShinaUSB}:

\begin{enumerate}
\item управляющие посылки (Control Transfers), используемые для конфигурирования во время подключения 
и в процессе работы для управления устройствами.
\item сплошные передачи (Bulk Data Transfers) сравнительно больших пакетов без жестких требований 
ко времени доставки. Пакеты имеют поле данных размером 8, 16, 32 или 64 байт. Приоритет этих передач 
самый низкий, они могут приостанавливаться при большой загрузке шины.
\item прерывания (Interrupt) - короткие передачи, имеют спонтанный характер и должны обслуживаться не 
медленнее, чем того требует устройство. 
\item изохронные передачи (Isochronous Transfers) - непрерывные передачи в реальном времени, 
занимающие предварительно согласованную часть пропускной способности шины и имеющие заданную 
задержку доставки.
\end{enumerate}

\subsubsection{Основные поля структуры URB~\cite{LinuxCode}}

\begin{itemize}[label=---]
    \item \texttt{struct usb\_device *dev} -- представление устройства USB;
    \item \texttt{int status} -- статус выполнения;
    \item \texttt{void *transfer\_buffer} -- указатель на область данных для передачи;
    \item \texttt{u32 transfer\_buffer\_length} -- размер передаваемого буфера;
    \item \texttt{struct scatterlist *sg} -- указатель на начало списка разрозненных буферов для передачи;
    \item \texttt{int num\_sgs} -- длина списка разрозненных буферов;
    \item \texttt{u32 actual\_length} -- фактически переданное количество байт;
    \item \texttt{unsigned int transfer\_flags} -- флаги передачи. Флаг URB\_NO\_TRANSFER\_DMA\_MAP
    сообщает драйверу хост-контроллера, что драйвер устройства поддерживает DMA(Direct Memory Access);
    \item \texttt{dma\_addr\_t transfer\_dma} -- физический адрес передаваемых данных. Если установлен 
    флаг URB\_NO\_TRANSFER\_DMA\_MAP драйвер устройства сообщает, что он предоставил этот адрес DMA,
    который драйвер хост-контроллера должен использовать предпочтительнее, чем transfer\_buffer;
    \item \texttt{usb\_complete\_t complete} -- функция обратного вызова. Используется для освобождения
    или повторной отправки URB.
\end{itemize}

\subsection{struct usb\_device}

Структура \texttt{usb\_device} отвечает за представление USB-устройства в ядре. 

\subsubsection{Основные поля структуры usb\_device}

\begin{itemize}[label=---]
\item \texttt{int devnum} -- номер устройства в системе. Уникальный идентификатор, присваиваемый 
устройству при его подключении;
\item \texttt{char devpath[16]} -- путь к устройству в дереве USB. Строка, представляющая 
путь от корневого хаба до устройства;
\item \texttt{struct usb\_device\_descriptor descriptor} -- содержит стандартный дескриптор 
устройства (идентификатор производителя, идентификатор продукта, версия устройства и т.д.);
\item \texttt{enum usb\_device\_state state} -- текущее состояние устройства;
\item \texttt{unsigned can\_submit\_urbs} -- флаг, указывающий, можно ли отправлять URBs.
\end{itemize}

\section{Анализ основных функций ядра для работы с USB}

Для работы с устройствами USB в ядре существует множество функций, описанных
в файлах \texttt{/drivers/usb/core/urb.c}, \texttt{/drivers/usb/core/usb.c}, 
\texttt{/drivers/usb/core/hcd.c}.

\subsection{usb\_submit\_urb}

Функция имеет следующую сигнатуру:

\texttt{int usb\_submit\_urb(struct urb *urb, gfp\_t mem\_flags)}.

Функция отправляет запрос на передачу, передавая URB, описывающее этот запрос, 
в подсистему USB. Завершение запроса идентифицируется позднее, асинхронно,
при вызове обработчики завершения. URBs могут отправляться конечным точкам до завершения
предыдущих, чтобы минимизировать задержки. Таким образом очередь на конечной точке
никогда не будет пустой. Такая организация позволяет максимально эффективно использовать
полосу пропускания, позволяя USB контроллерам начинать работу с более поздними запросами
до того, как программное обеспечение драйвера завершит обработку более ранних запросов.

В случае успеха функция возвращает 0, иначе -- отрицательный номер ошибки.

\subsection{usb\_hcd\_link\_urb\_to\_ep}

Функция имеет следующую сигнатуру:

\texttt{int usb\_hcd\_link\_urb\_to\_ep(struct usb\_hcd *hcd, struct urb *urb)}.

Функция добавляет URB в очередь конечной точки. Принимает структуру хост-контроллера,
на который был отправлен URB и сам URB. Драйверы хост-контроллера должны вызывать эту 
процедуру в своем методе \texttt{enqueue()}. Возвращает значение 0, если ошибки нет, 
в противном случае возвращается отрицательный код ошибки (в этом случае метод \texttt{enqueue()} 
должен завершиться ошибкой).

\section{Анализ методов динамической отладки функций ядра}

В ядре Linux существует несколько механизмов отладки функций ядра.

\subsection{kprobes}

Kprobes -- это средс­тво динами­чес­кой отладки ядра, поз­воля­ющее ста­вить breakpoints на 
дос­тупные для записи учас­тки памяти и самос­тоятель­но обра­баты­вать их. Описывается структурой
\texttt{kprobes}, имеющей следующие поля:

\begin{itemize}[label=---]
    \item \texttt{const char *symbol\_name} -- имя функции, на которую ставится breakpoint;
    \item \texttt{kprobe\_pre\_handler\_t pre\_handler} -- указатель на функцию обработки точки
    останова до выполнения основной функции;
    \item \texttt{kprobe\_post\_handler\_t post\_handler} -- указатель на функцию обработки точки
    останова после выполнения основной функции;
    \item \texttt{kprobe\_opcode\_t *addr} -- адрес функции, на которую ставится breakpoint.
    Должно быть указано либо имя функции, либо её адрес, если заполнены оба поля, то 
    регистрация kprobe вернёт ошибку -EINVAL~\cite{Kprobes}.
\end{itemize}

Добавление и удаление точек останова выполняют следующие функции:

\includelisting
    {kprobe_reg_unreg.c}
    {Функции добавления и удаления kprobes}

\subsection{Livepatch}

Livepatch -- механизм для исправление критических уязвимостей безопасности и критических 
ошибок в системах с высокими требованиями к доступности. Основан на подмене целых функций 
ядра на их исправленные версии во время выполнения системы.

Структура \texttt{klp\_func} описывает подменяемую функцию:

\begin{itemize}[label=---]
\item \texttt{const char *old\_name} -- имя оригинальной функции;
\item \texttt{void *new\_func} -- указатель на исправленную функцию;
\item \texttt{struct list\_head stack\_node} -- узел списка для отслеживания вызовов функции;
\item \texttt{bool patched} -- флаг, указывающий, применён ли патч к данной функции.
\end{itemize}

Структура \texttt{klp\_object} описывает модуль, содержащий функции для замены:

\begin{itemize}[label=---]
\item \texttt{const char *name} -- имя модуля;
\item \texttt{struct module *mod} -- указатель на структуру модуля;
\item \texttt{struct klp\_func *funcs} -- список функций для патчинга;
\item \texttt{bool patched} -- флаг, указывающий, применён ли патч ко всем функциям объекта.
\end{itemize}

Структура \texttt{klp\_patch} описывает единый патч, который может включать несколько объектов:

\begin{itemize}[label=---]
\item \texttt{struct list\_head list} -- узел для включения в глобальный список патчей;
\item \texttt{struct klp\_object *objs} -- объекты, входящие в патч;
\item \texttt{struct module *mod} -- указатель на модуль, реализующий патч;
\item \texttt{bool enabled} -- флаг активности патча;
\item \texttt{bool replace} -- флаг, указывающий, должен ли патч заменять предыдущие.
\end{itemize}

Для включения патча необходимо вызвать следующую функцию:

int klp\_enable\_patch(struct klp\_patch *patch)

Она инициализирует структуру \texttt{klp\_patch}, выполняет необходимый поиск символов и 
перемещение кода, регистрирует исправленные функции с помощью ftrace.

\subsection{Выбор метода динамической отладки функций ядра}

Для реализации поставленной задачи \texttt{Livepatch} избыточен, так как необходимо не исправлять 
ошибку в ядре, а добавлять новую функциональность. К тому же подменённая функция вызывалась бы
для всех USB устройств, а не для конкретной флешки, что невыгодно и может нарушить 
работу других устройств. Единственным вариантом остаётся \texttt{kprobes}.

\section{Файловая система FAT32}

Файловая система получила название от одноимённой таблицы размещения файлов -- File 
Allocation Table, FAT. 32 в названии указывает на размер элемента таблицы(32 бита).
В FAT32 четыре старших двоичных разряда зарезервированы и игнорируются в процессе 
работы операционной системы~\cite{FAT32}.

На рисунке~\ref{img:FAT} изображена структура раздела FAT:

\includeimage
    {FAT}
    {f}
    {H}
    {0.60\textwidth}
    {Структура раздела FAT32}

В файловой системе FAT дисковое пространство логического раздела делится на две 
области -- системную и область данных. Системная область создается и инициализируется при 
форматировании, а впоследствии обновляется при манипулировании файловой структурой.

Область данных логического диска содержит файлы и каталоги, подчиненные корневому, и 
разделена на участки одинакового размера -- кластеры. Кластер может состоять из одного 
или нескольких последовательно расположенных на диске секторов. Число секторов в кластере 
должно быть кратно степени двойки и может принимать значения от 1 до 64. 

Каждому кластеру соответствует элемент таблицы FAT, содержащий информацию о том, свободен 
данный кластер или занят данными файла. Если кластер занят под файл, то в соответствующем
элементе таблицы размещения файлов указывается адрес кластера, содержащего следующую часть 
файла. Номер начального кластера, занятого файлом, хранится в элементе каталога, 
содержащего запись об этом файле. Последний элемент списка кластеров содержит признак
конца файла. Первые два элемента FAT являются резервными.

В FAT32 корневой каталог может быть расположен в любом месте области данных раздела и 
иметь произвольный размер. Структура элемента каталога файлов показана на 
рисунке~\ref{img:CatalogFAT}. Элемент начинается с 11-байтного поля, содержащего «короткое имя» 
файла, по которому операционная система обычно осуществляет поиск файла в каталоге. 
«Короткое имя» состоит из двух полей: 8-байтного поля, содержащего собственно имя файла 
и 3-байтного поля, содержащего расширение. Разделительная точка между именем и расширением 
файла не хранится в структуре данных.

\includeimage
    {CatalogFAT}
    {f}
    {H}
    {0.90\textwidth}
    {Структура элемента каталога}

4 бит в поле аттрибутов файла, равный единице, определяет файл как каталог.
Если первый байт короткого имени равен 0xE5, то элемент каталога свободен и его можно 
использовать при создании нового файла.

\section{Выводы}

В результате проведённого анализа был выбран механизм динамической отладки kprobes для 
реализации модуля ядра. 
Была рассмотрена архитектура подсистемы USB в Linux, основные структуры и функции работы и 
представления USB, а также изучено строение файловой системы FAT32, на которой работает 
USB-накопитель.